# 最有价值的50道java面试题
## 面向对象的特征有哪些方面?
### 抽象
```text
抽象是将一类对象的共同特征总结出来构造类的过程，
包括数据抽象和行为抽象
抽象只关注对象有哪些行为和属性，并不关心这些行为的细节是什么
```
### 继承
```text
 继承是从已有类得到继承信息创建新类的过程。
 提供继承信息的称为父类
 得到继承信息的称为子类
```
### 封装

通常认为封装是把数据和操作数据的方法绑定起来，对数据的访问只能通过已定义的接口。

### 多态性
```text
多态性是指允许不同子类型的对象对同一消息作出不同的响应。
简单的说就是用同样的对象引用调用同样的方法但是做了不同的事情。
多态性分为编译时的多态性和运行时的多态性。
如果将对象的方法视为对象向外界提供的服务，那么运行时的多态性可以解释为：
当A系统访问B系统提供的服务时，B系统有多种提供服务的方式，
但一切对A系统来说都是透明的（就像电动剃须刀是A系统，它的供电系统是B系统，
B系统可以使用电池供电或者用交流电，甚至还有可能是太阳能，
A系统只会通过B类对象调用供电的方法，但并不知道供电系统的底层实现是什么，
究竟通过何种方式获得了动力）。
方法重载（overload）实现的是编译时的多态性（也称为前绑定），
而方法重写（override）实现的是运行时的多态性（也称为后绑定）。
运行时的多态是面向对象最精髓的东西，要实现多态需要做两件事：
1. 方法重写（子类继承父类并重写父类中已有的或抽象的方法）；
2. 对象造型（用父类型引用引用子类型对象，这样同样的引用调用同样的方法
就会根据子类对象的不同而表现出不同的行为）。 
```
## String 是最基本的数据类型吗?

不是。Java中的基本数据类型只有8个：
byte、short、int、long、float、double、char、boolean；
除了基本类型（primitive type）和枚举类型（enumeration type），
剩下的都是引用类型（reference type）。

## float f=3.4;是否正确?

不正确。
3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型
（down-casting，也称为窄化）会造成精度损失，
因此需要强制类型转换float f =(float)3.4; 
或者写成float f =3.4F。 

## short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗?

对于short s1 = 1; s1 = s1 + 1;
由于1是int类型，因此s1+1运算结果也是int 型，
需要强制转换类型才能赋值给short型。

而short s1 = 1; s1 += 1;可以正确编译，
因为s1+= 1;相当于s1 = (short)(s1 + 1);其中有隐含的强制类型转换。 

## Java 有没有goto?

goto 是Java中的保留字，在目前版本的Java中没有使用。

## int 和Integer 有什么区别?

Java是一个近乎纯洁的面向对象编程语言，
但是为了编程的方便还是引入不是对象的基本数据类型，
但是为了能够将这些基本数据类型当成对象操作，
Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），
int的包装类就是Integer，从JDK 1.5开始引入了自动装箱/拆箱机制，
使得二者可以相互转换。

Java 为每个原始类型提供了包装类型：

原始类型: boolean，char，byte，short，int，long，float，double

包装类型：Boolean，Character，Byte，Short，Integer，Long，Float，Double

## &和&&的区别？ 

&运算符有两种用法：(1)按位与；(2)逻辑与。

&&运算符是短路与运算。

逻辑与跟短路与的差别是非常巨大的，虽然二者都要求运算符左右两端的布尔值都是true
整个表达式的值才是true。

&&之所以称为短路运算是因为，如果&&左边的表达式的值是false，
右边的表达式会被直接短路掉，不会进行运算。

很多时候我们可能都需要用&&而不是&，例如在验证用户登录时判定用户名不是null而且不是
空字符串，应当写为：username != null &&!username.equals(“”)，二者的顺序不能交换，
更不能用&运算符，因为第一个条件如果不成立，根本不能进行字符串的equals比较，
否则会产生NullPointerException异常。

注意：逻辑或运算符（|）和短路或运算符（||）的差别也是如此。

## 解释内存中的栈（stack）、堆(heap)和静态存储区的用法。

通常我们定义一个基本数据类型的变量，一个对象的引用，
还有就是函数调用的现场保存都使用内存中的栈空间；

而通过new关键字和构造器创建的对象放在堆空间；

程序中的字面量（literal）如直接书写的100、“hello”和常量都是放在静态存储区中。

栈空间操作最快但是也很小，通常大量的对象都是放在堆空间，整个内存包括硬盘上的虚拟
内存都可以被当成堆空间来使用。

String str = new String(“hello”);

上面的语句中str放在栈上，用new创建出来的字符串对象放在堆上，
而“hello”这个字面量放在静态存储区。

补充：较新版本的Java中使用了一项叫“逃逸分析“的技术，可以将一些局部对象放在栈上
以提升对象的操作性能。 

## Math.round(11.5) 等于多少? Math.round(-11.5)等于多少?

Math.round(11.5)的返回值是12，Math.round(-11.5)的返回值是-11。
四舍五入的原理是在参数上加0.5然后进行下取整。

## swtich 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上?

早期的JDK中，switch（expr）中，expr可以是byte、short、char、int。

从1.5版开始，Java中引入了枚举类型（enum），expr也可以是枚举，

从JDK 1.7版开始，还可以是字符串（String）。长整型（long）是不可以的。

## 用最有效率的方法计算2乘以8?

 2 << 3（左移3位相当于乘以2的3次方，右移3位相当于除以2的3次方）。
 
## 在Java 中，如何跳出当前的多重嵌套循环？

在最外层循环前加一个标记如A，然后用break A;可以跳出多重循环。

## 构造器（constructor）是否可被重写（override）?
构造器不能被继承，因此不能被重写，但可以被重载。

## 两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？
不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。

Java对于eqauls方法和hashCode方法是这样规定的：

(1)如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；

(2)如果两个对象的hashCode相同，它们并不一定相同。

当然，你未必要按照要求去做，但是如果你违背了上述原则就会发现在使用容器时，
相同的对象可以出现在Set集合中，同时增加新元素的效率会大大下降
（对于使用哈希存储的系统，如果哈希码频繁的冲突将会造成存取性能急剧下降）。

## 是否可以继承String 类?
String 类是final类，不可以被继承。

## 当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递?
是值传递。

Java 编程语言只有值传递参数。当一个对象实例作为一个参数被传递到方法中时，
参数的值就是对该对象的引用。
对象的属性可以在被调用过程中被改变，但对象的引用是永远不会改变的。
C++和C#中可以通过传引用或传输出参数来改变传入的参数的值。

## 描述一下JVM 加载class文件的原理机制?
JVM 中类的装载是由类加载器（ClassLoader） 和它的子类来实现的，
Java中的类加载器是一个重要的Java 运行时系统组件，
它负责在运行时查找和装入类文件中的类。 

## Java 中会存在内存泄漏吗，请简单描述。
理论上Java因为有垃圾回收机制（GC）不会存在内存泄露问题
（这也是Java被广泛使用于服务器端编程的一个重要原因）；

然而在实际开发中，可能会存在无用但可达的对象，这些对象不能被GC回收也会发生内存泄露。

一个例子就是Hibernate的Session（一级缓存）中的对象属于持久态，
垃圾回收器是不会回收这些对象的，然而这些对象中可能存在无用的垃圾对象。

## 静态变量和实例变量的区别？
静态变量是被static修饰符修饰的变量，也称为类变量，它属于类，不属于类的任何一个对象，
一个类不管创建多少个对象，静态变量在内存中有且仅有一个拷贝；
实例变量必须依存于某一实例，需要先创建对象然后通过对象才能访问到它。
静态变量可以实现让多个对象共享内存。
在Java开发中，上下文类和工具类中通常会有大量的静态成员。

## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 
## 